PyBuildTool
===========

* License      : MIT
* Project URL  : [PyBuildTool][3]
* Project Wiki : [Wiki at PyBuildTool][4]

Summary
-------

PyBuildTool is build-tools platform written in python, with [waf][1] as
its foundation.

Basically you take some files, run a process that transform them into
different files or file types, using tools.

There are builtin tools, but you can make your own, see the modules in
**pybuildtool** directory and how they were included in the file wscript
as example.

As a user, the only file you need to regularly maintain is **build_rules.yml**.

There're three stages predefined: "dev", "stage", and "prod", but the
functionality isn't there yet, they have separate build directory of their own,
but they still share the same build rules.

Currently stages is implemented like this, for `cleancss` rule, if the current
stage is one of "dev" or "devel" or "development" it will do copy operation
instead of minification.

Example content of **build_rules.yml**, pretend it's a django project:

    JSHINT_EXCLUDES: &JSHINT_EXCLUDES
        - "{_1}/{_2}/js/jquery.js"
        - "{_1}/{_2}/js/require.js"
        - "{_1}/{_2}/js/underscore.js"

    djangoprj:
        blogapp:
            jshint:
                options:
                    _source_sandboxed_: false
                    config_file: "etc/jshint.rc"
                file_in: "{_1}/{_2}/js/**/*.js"
                token_out: "{_1}:{_2}:{_3}"
            concat:
                token_in: "{_1}/{_2}/jshint"
                file_in: "{_1}/{_2}/js/**/*.js"
                file_out: "js/blogapp.js"
        djangoprj:
            jshint:
                options:
                    _source_sandboxed_: false
                    _source_excluded_: *JSHINT_EXCLUDES
                    config_file: "etc/jshint.rc"
                file_in: "{_1}/{_2}/js/**/*.js"
                token_out: "{_1}:{_2}:{_3}"
            jscs:
                options:
                    _source_sandboxed_: false
                    _source_excluded_: *JSHINT_EXCLUDES
                    config_file: "etc/jscs.rc"
                file_in:
                    - "{_1}/{_2}/js/**/*.js"
                token_out: "{_1}:{_2}:{_3}"
            pylint:
                options:
                    _source_sandboxed_: false
                    config_file: "etc/pylint.rc"
                file_in:
                    - "{_1}/{_2}/**/*.py"
                token_out: "{_1}:{_2}:{_3}"
            concat:
                token_in:
                    -   "@djangoprj:djangoprj:jshint"
                    -   "@{_1}:{_2}:jscs"
                file_in:
                    -   "{_1}/{_2}/js/**/*.js"
                    -   "@{_1}:blogapp:concat"
                file_out: "js/djangoprj.js"
            uglifyjs:
                file_in: "@{_1}:{_2}:concat"
                file_out: "minified_js/"


Several things to keep in mind:

-   "djangoprj", "blogapp", "jshint", "concat" are group names.

-   JSHINT_EXCLUDES is not a group name (it matches all capital letters and
    underscore), pybuildtool will not recognize this entry, but yaml.load will,
    it can be used as [yaml node anchor][6].

-   `{_1}` is string replacement for group name.

-   because group name can be used as string replacement for file
    names, they can be used to represent directory structure.

-   "@djangoprj:djangoprj:jshint" is a reference to files or token
    generated by the rule "djangoprj"-"djangoprj"-"jshint", that is,
    its file_out and token_out.

-   you can use [ant glob][5] like this `**/*.js`

-   you can use directory as output, they must end with path separator, for
    example: "minified_js/"

-   the child-most groups are special, they must match tool name like "jshint",
    "concat", "pylint", "uglifyjs", etc.

-   rules are read in the order they are written, you can reference other rules
    generated output files as a rule input files but those rules must have been
    specified before.
    we don't support lazy load of rules yet.

-   the option field: `_source_sandboxed_` is used for `waf watch` to get list
    of files need to be monitored for changes.

-   the option field: `_source_excluded_` is list of files which will be
    excluded from inputs.

-   the option field: `_target_sandboxed_` means this rule output will be
    written in the actual file system, by default it's generated inside
    '.BUILD/stage/' directory.

-   the option field: `config_file` is configuration item provided by each
    tools, in this case it was provided by "pylint", "jshint", and "jscs", and
    they happens to have used the same option field name.


Warning
-------

`waf` does not like it if the source and target existed in the same directory,
see: [Files are always built][7].


Install
-------

1.   Create virtualenv, activate it

2.   `pip install https://github.com/dozymoe/PyBuildTool/archive/master.zip`

3.   Install `waf`, just download from [waf project][1] into your shell PATH or
     your virtualenv "bin" directory

     Alternative is to run `pip install waftools` then run `wafinstall`

4.   copy `wscript` file from you virtualenv directory to your project directory

5.   Create `build_rules.yml` file with content like our example, this will be
     your build rules.

6.   `waf configure`

7.   `waf build_dev`


[1]: http://code.google.com/p/waf/
[3]: http://github.com/dozymoe/PyBuildTool
[4]: http://github.com/dozymoe/PyBuildTool/wiki
[5]: http://ant.apache.org/manual/dirtasks.html
[6]: http://yaml.org/spec/1.2/spec.html#id2785586
[7]: https://code.google.com/p/waf/wiki/FAQ#The_same_files_are_always_built
