PyBuildTool
===========

* License      : MIT
* Project URL  : [PyBuildTool][3]
* Project Wiki : [Wiki at PyBuildTool][4]

Summary
-------

PyBuildTool is build-tools platform written in python, with [waf][1] as
its foundation.

Basically you take some files, run a process that transform them into
different files or file types, using tools.

There are builtin tools, but you can make your own, see the modules in
**pybuildtool** directory and how they were included in the file wscript
as example.

As a user, the only file you need to regularly maintain is **build_rules.yml**.

There're three stages predefined: "dev", "stage", and "prod", but the
functionality isn't there yet, they have separate build directory of their own,
but they still share the same build rules.

Currently stages is implemented like this, for `cleancss` rule, if the current
stage is one of "dev" or "devel" or "development" it will do copy operation
instead of minification.

Example content of **build_rules.yml**, pretend it's a django project:

    # Macro, reusable definition
    JSHINT_EXCLUDES: &JSHINT_EXCLUDES
        - "{_1}/{_2}/js/jquery.js"
        - "{_1}/{_2}/js/require.js"
        - "{_1}/{_2}/js/underscore.js"


    djangoprj:
        options:
          # Lower level tool's configurations defined in the higher level
          # group
          jshint_config_file: "etc/jshint.rc"
          pylint_config_file: "etc/pylint.rc"

        blogapp:
            jshint:
                # Wildcards is a okay 0.0b (see ant-glob)
                file_in: "{_1}/{_2}/js/**/*.js"
                # Tokens are virtual keys (not real files), can be used
                # as dependency of another tool
                token_out: "{_1}:{_2}:{_3}"
            concat:
                # raw_file_in will be used in `waf watch`
                raw_file_in: "{_1}/{_2}/js/**/*.js"
                # The `{_1}/{_2}` will be replaced with the groups' names,
                # in this case it will be read as `djangoprj/blogapp`
                token_in: "{_1}/{_2}/jshint"
                # Relative files are relative to the directory where you
                # run `waf configure`
                file_out: "js/blogapp.js"

        djangoprj:
            # Test javascript files syntax for errors
            jshint:
                options:
                    # Macro usage
                    # Exclude some files listed in `file_in` from being
                    # processed
                    _source_excluded_: *JSHINT_EXCLUDES
                file_in: "{_1}/{_2}/js/**/*.js"
                token_out: "{_1}:{_2}:{_3}"
            # Test javascript files syntax for errors
            jscs:
                options:
                    # Macro usage
                    # Exclude some files listed in `file_in` from being
                    # processed
                    _source_excluded_: *JSHINT_EXCLUDES
                    # This one is defined here, not in higher level group
                    config_file: "etc/jscs.rc"
                file_in: "{_1}/{_2}/js/**/*.js"
                token_out: "{_1}:{_2}:{_3}"
            # Test python files syntax for errors
            pylint:
                raw_file_in: "{_1}/{_2}/**/*.py"
                token_out: "{_1}:{_2}:{_3}"
            # Concacenate javascript files into one file for production site
            concat:
                token_in:
                    # Can has multiple items
                    -   "@djangoprj:djangoprj:jshint"
                    -   "{_1}:{_2}:jscs"
                # The `@` symbol means use the files output of another tool
                file_in: "@{_1}:blogapp:concat"
                raw_file_in: "{_1}/{_2}/js/**/*.js"
                file_out: "js/djangoprj.js"
            # Copy final javascript file to production directory
            cp:
                file_in: "@{_1}:{_2}:concat"
                # Files usually produced in a sandbox directory, raw_file_out
                # directive made it produced in the actual project directory
                raw_file_out: "dist/"
            # Copy compressed final javascript file to production
            # directory
            uglifyjs:
                file_in: "@{_1}:{_2}:concat"
                # Directory as target is a okay 0.0d
                raw_file_out: "dist/"


Several things to keep in mind:

-   "djangoprj", "blogapp", "jshint", "concat" are group names.

-   JSHINT_EXCLUDES is not a group name (it matches all capital letters and
    underscore), pybuildtool will not recognize this entry, but yaml.load will,
    it can be used as [yaml node anchor][6].

-   `{_1}` is string replacement thingy for a group name based on the
    group's level.

-   because group name can be used as string replacement for file
    names, they can be used to represent directory structure.

-   "@djangoprj:djangoprj:jshint" is a reference to files or token
    generated by the rule "djangoprj"-"djangoprj"-"jshint", that is,
    the combination of its `file_out`, `raw_file_out` and `extra_out`.

-   you can use [ant glob][5] like this `**/*.js`

-   you can use directory as output, they must end with path separator, for
    example: "minified_js/"

-   the child-most groups are special, they must match tool name like "jshint",
    "concat", "pylint", "uglifyjs", etc.

-   rules are read in the order they are written, you can reference other rules
    generated output files as a rule input files but those rules must have been
    specified before.
    we don't support lazy load of rules yet.

-   the directive `raw_file_in` or `raw_depend_in` is used for `waf watch`
    to get list of files need to be monitored for changes.

-   the directive `depend_in` can be used to force the tool to process `file_in`
    if files in `depend_in` changes.

-   the directive `extra_out` can be used to list auxiliary files produced by the
    tools, it can be used with combination of `@group:group` directive as inputs
    of another tool.

-   the option field: `_source_excluded_` is list of files which will be
    excluded from inputs.

-   the directive `raw_file_out` means this rule's outputs will be
    written in the actual file system, by default it's generated inside
    '.BUILD/stage/' directory.

-   the option field: `config_file` is configuration item provided by each
    tools, in this case it was provided by "pylint", "jshint", and "jscs", and
    they happens to have used the same option field name.  
    when option field is placed in higher group level, it's prefixed with the
    tool name, for example: "jscs_config_file"


Warning
-------

`waf` does not like it if the source and target existed in the same directory,
see: [Files are always built][7].


Install
-------

1.   Create virtualenv, activate it

2.   `pip install git+https://github.com/dozymoe/PyBuildTool@v1.1.1` or
     `pip install https://github.com/dozymoe/PyBuildTool/archive/master.zip`

3.   Install `waf`, just download from [waf project][1] into your shell PATH or
     your virtualenv "bin" directory

     Alternative is to run `pip install waftools` then run `wafinstall`, caution:
     this method will modify your `.bashrc` file, adds `WAFDIR=???`

4.   copy `wscript` file from you virtualenv directory to your project directory

5.   Create `build_rules.yml` file with content like our example, this will be
     your build rules.

6.   `waf configure`

7.   `waf build_dev` or `waf watch_dev`


[1]: https://waf.io/
[3]: http://github.com/dozymoe/PyBuildTool
[4]: http://github.com/dozymoe/PyBuildTool/wiki
[5]: http://ant.apache.org/manual/dirtasks.html
[6]: http://yaml.org/spec/1.2/spec.html#id2785586
[7]: https://code.google.com/p/waf/wiki/FAQ#The_same_files_are_always_built
